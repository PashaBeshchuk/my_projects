<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Snake</title>
		<style>
			.foodForSnake{
				background:blue;
			}
			.paintSnakeBody{
				background:white;
			}
			.snakeDied{
				background:yellow;
			}
			tr{
				margin-bottom:0px;
				padding:0px;
			}
			table{
				border:1px solid black;
				border-spacing:0px;
				//margin:auto;
				background:black;
			}
			
			@media screen and (min-width: 280px) and (max-width: 480px){
				td{
					width:5px;
					height:5px;
					margin:0px;
					padding:0px;
					
				}
			}
			
			@media screen and (min-width: 480px) and (max-width: 600px){
				td{
					width:8px;
					height:8px;
					margin:0px;
					padding:0px;
					
				}
			}
			@media screen and (min-width: 600px) and (max-width: 800px) {
				td{
					width:10px;
					height:10px;
					margin:0px;
					padding:0px;				
				}
			}
			@media screen and (min-width: 800px) and (max-width: 1000px) {
				td{
					width:12px;
					height:12px;
					margin:0px;
					padding:0px;				
				}
			}
			
			@media screen and (min-width: 1000px) {
				td{
					width:14px;
					height:14px;
					margin:0px;
					padding:0px;
				}
				
			}
			
		</style>
		
	</head>
	<body>

	<script>
		var numberOfLines = 4;
		var numberOfCellsPerLine = 6;
		var snakeDirectionLeft = 37;
		var snakeDirectionRight = 39;
		var snakeDirectionUp = 38;
		var snakeDirectionDow = 40;
		var keyCodeRightButton = snakeDirectionRight;
		var keyCodeLeftButton = snakeDirectionLeft;
		var keyCodeUpButton = snakeDirectionUp;
		var keyCodeDownButton = snakeDirectionDow;
		var cellsPerSecond = 1;
		var second = 1000;
		var bodySnakePosition = [[numberOfLines/2,numberOfCellsPerLine/2]];
		var keyCode;
		var foodPosition;
		var headSnake;
		var snakeIsAlive = window.setInterval(tick, second/cellsPerSecond);
		var oldPositionSnake;
		var lastKeyCode;
		var keystrokeHistory = [];
		var snakeLength = 2;
		
		
		window.addEventListener("keydown", saveKeyCode);
		buildField(numberOfLines, numberOfCellsPerLine);
		buildBodyForSnake(snakeLength, bodySnakePosition);
		paintSnakeBody(bodySnakePosition);
		
		function tick(){
			keyCodeRightButton = snakeDirectionRight;
			keyCodeLeftButton = snakeDirectionLeft;
			keyCodeUpButton = snakeDirectionUp;
			keyCodeDownButton = snakeDirectionDow;
			oldPositionSnake = bodySnakePosition.slice(0);
			if(defineStep(keyCodeRightButton, keyCodeLeftButton, keyCodeUpButton, keyCodeDownButton) === undefined){
				return;
			}
			removeBodySnake(oldPositionSnake);
			var step = defineStep(keyCodeRightButton, keyCodeLeftButton, keyCodeUpButton, keyCodeDownButton);
			headSnake = bodySnakePosition[0];
			headSnake = [headSnake[0] + step[0],headSnake[1] + step[1]];
			bodySnakePosition.unshift(headSnake);
			bodySnakePosition.pop();
			killSnake(oldPositionSnake);
			if(foodPosition === undefined){
				setPositionForFood(bodySnakePosition,foodPosition);
				createFood(foodPosition);
			}
			paintSnakeBody(bodySnakePosition);
			if(arraysEqual(bodySnakePosition[0],foodPosition)){
				removeFood(bodySnakePosition[0]);
				bodySnakePosition.push(foodPosition);
				foodPosition = undefined;
			}
			lastKeyCode = keyCode;
			keystrokeHistory = [];
			
		}
		
		function buildField(fieldLines, fieldCells){
			var table  = document.createElement("table");
			document.body.appendChild(table);
						 
			for(var fieldLength  = 0; fieldLength < fieldLines; fieldLength++){
				var line = document.createElement("tr");
				table.appendChild(line);
				
				 for(var fieldWidth = 0; fieldWidth < fieldCells; fieldWidth++){
					var cells = document.createElement("td");
					line.appendChild(cells);
				}				
			}
		}
		
		function getCell(variable){
			var allLinesOnField = document.querySelectorAll("tr");
			return allLinesOnField[variable[0]].childNodes[variable[1]];
		}
		 
		function paintSnakeBody(positionSnake){
			for(var numberSnakeBodyElement = 0; numberSnakeBodyElement < positionSnake.length; numberSnakeBodyElement++){
				getCell(positionSnake[numberSnakeBodyElement]).classList.add("paintSnakeBody");
			}
			
		}
		
		function saveKeyCode(e){
			if(e.keyCode == keyCodeRightButton || e.keyCode == keyCodeLeftButton || e.keyCode == keyCodeUpButton || e.keyCode == keyCodeDownButton){
				keyCode = e.keyCode;
				defineTheLastButtonPressed(keyCode, lastKeyCode, keystrokeHistory);
			}
		}
		
		function removeBodySnake(positionSnake){
			for(var numberSnakeBodyElement = 0; numberSnakeBodyElement < positionSnake.length; numberSnakeBodyElement++){
				getCell(positionSnake[numberSnakeBodyElement]).classList.remove("paintSnakeBody");
			}
		}
				
		function defineStep(rightButton, leftButton, upButton, downButton){
			switch(keyCode){
				case rightButton:
					return [0, 1];
				case leftButton:
					return [0,-1];
				case upButton:
					return [-1, 0];
				case downButton:
					return [1, 0];
				default:
					return undefined;
			}
		}
			
		function setPositionForFood(coordinatesPositionSnake,coordinatesFood){
			var suitableNumber = false;
			while(suitableNumber === false){
				suitableNumber = true;
				coordinatesFood = [
					(Math.floor(Math.random()*numberOfLines)),
					(Math.floor(Math.random()*numberOfCellsPerLine))
				];
				for(var numberSnakeBodyElement = 0; numberSnakeBodyElement < coordinatesPositionSnake.length; numberSnakeBodyElement++){
					if(arraysEqual(coordinatesPositionSnake[numberSnakeBodyElement],coordinatesFood)){
						suitableNumber = false;
						break;
					}
				}
			}
			foodPosition = coordinatesFood.slice(0);
			return coordinatesFood;
		}		
		
		function buildBodyForSnake(lengthBody, SnakePosition){
			for(var tailNumberSnake = 1; tailNumberSnake < lengthBody; tailNumberSnake++){
				var mathClone = SnakePosition[0].slice(0);
				mathClone[1] = mathClone[1] + tailNumberSnake;
				SnakePosition.push(mathClone);
			}
			return SnakePosition;
		}
		
		function killSnake(positionSnake){
			var snakeHead = bodySnakePosition[0];
			if(snakeHead[0] == -1 || snakeHead[1] == -1){
				paintedDeadSnake(positionSnake);
			}
			if(snakeHead[0] == numberOfLines){
				paintedDeadSnake(positionSnake);
			}
			if(snakeHead[1] == numberOfCellsPerLine){
				paintedDeadSnake(positionSnake);
			}
			for(var bodyElementSnake = 1; bodyElementSnake < bodySnakePosition.length; bodyElementSnake++){	
				if(arraysEqual(snakeHead,bodySnakePosition[bodyElementSnake])){
					paintedDeadSnake(positionSnake);
					break;
				}
			}
		}
		
		function paintedDeadSnake(positionSnake){
			clearInterval(snakeIsAlive);
			for(var snakeBodyNumber = 0; snakeBodyNumber < positionSnake.length; snakeBodyNumber++){
				getCell(positionSnake[snakeBodyNumber]).classList.add("snakeDied");
			}
		}
		
		function arraysEqual(firstArray,sacondArray){
			return firstArray.toString() === sacondArray.toString();
		}
		
		function createFood(snakeFood){
			getCell(snakeFood).classList.add("foodForSnake");
		}
		
		function removeFood(headSnake){
			getCell(headSnake).classList.remove("foodForSnake");
		}
		function defineTheLastButtonPressed(newKeyCode, lastKeyCod, keyHistory){
			var keyPressed;
			keyPressed = newKeyCode
			keyHistory.push(keyPressed);
			console.log(keyHistory + " Массив кнопак")
			console.log(newKeyCode)
			if(keyHistory[keyHistory.length-1] == 39 && newKeyCode == 37){
				defineStep(keyCodeRightButton, keyCodeLeftButton, keyCodeUpButton, keyCodeDownButton) =  [0,-1];
				return defineStep(keyCodeRightButton, keyCodeLeftButton, keyCodeUpButton, keyCodeDownButton);
			}
			
			console.log( + " Последний элемент массива")
			
			console.log(lastKeyCode + " Старый код кнопки")
			console.log(defineStep(keyCodeRightButton, keyCodeLeftButton, keyCodeUpButton, keyCodeDownButton) + " направление")*/
		} 
		
	</script>
	</body>
<html>
